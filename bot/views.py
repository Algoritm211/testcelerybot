from django.shortcuts import render
__author__ = '@Alexey_Horbunov'
from rest_framework.response import Response
from rest_framework.views import APIView
import telebot
from telebot import types
from collections import defaultdict
import datetime
import time
import numpy as np
from pprint import pprint
from .models import User
from . import market


# Create your views here.
TOKEN = '1113179664:AAEaV5nToFyEdoOAF5NrhjjncnLCJKbHXGs'
bot = telebot.TeleBot(TOKEN)

class UpdateBot(APIView):

    def post(self, request):
        json_string = request.body.decode("UTF-8")
        update = telebot.types.Update.de_json(json_string)
        bot.process_new_updates([update])

        return Response({'code':200})


GOTOSET, FINAL = range(2)

keyboard_1 = telebot.types.ReplyKeyboardMarkup(True, False, row_width=1)
keyboard_1.row('My MarketCap')


USER_STATE = defaultdict(lambda: GOTOSET)
def get_state(message):
    return USER_STATE[message.chat.id]


def update_state(message, state):
    USER_STATE[message.chat.id] = state

'''WEBHOOK'''

# app = Flask(__name__)
#
# @app.route('/' + TOKEN, methods=['POST'])
# def get_message():
#     bot.process_new_updates([types.Update.de_json(
#         flask.request.stream.read().decode("utf-8"))])
#     return "!", 200
#
#
# @app.route('/', methods=["GET"])
# def index():
#     bot.remove_webhook()
#     bot.set_webhook(url="https://{}.herokuapp.com/{}".format(APP_NAME, TOKEN))
#     return "Hello from CoinsInfo Bot!", 200

@bot.message_handler(commands=['start'])
def message_start(message):
    bot.send_message(message.chat.id, 'ü§ñ–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ, '+ message.from_user.first_name + '!\n' \
    'üíµ–Ø –º–æ–≥—É –ø–æ–∫–∞–∑–∞—Ç—å –í–∞–º —Ü–µ–Ω—ã —Ü–∏—Ñ—Ä–æ–≤—ã—Ö –∞–∫—Ç–∏–≤–æ–≤ —Å –±–∏—Ä–∂–∏ Binance, –∞ —Ç–∞–∫–∂–µ –æ—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å –í–∞—à–∏ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç—ã \n\n' +
    '–î–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–∞–∂–º–∏—Ç–µ /help.\n\n\n', reply_markup=keyboard_1)
    curr_date = now.strftime("%d-%m-%Y")
    user = User()
    user.user_id = message.chat.id
    user.save()

@bot.message_handler(commands=['help'])
def message_help(message):
    markup_author = types.InlineKeyboardMarkup(row_width=1)
    item_author = types.InlineKeyboardButton('–û–± –∞–≤—Ç–æ—Ä–µ –±–æ—Ç–∞', callback_data='author')
    # markup_author.add(item_author)
    bot.send_message(message.chat.id, '‚ùì–ò—Ç–∞–∫, –≤ –Ω–∞—Å—Ç–æ—è—â–∏–π –º–æ–º–µ–Ω—Ç –±–æ—Ç –º–æ–∂–µ—Ç –ø–æ–∫–∞–∑–∞—Ç—å –í–∞–º —Ü–µ–Ω—É —Ü–∏—Ñ—Ä–æ–≤—ã—Ö –∞–∫—Ç–∏–≤–æ–≤ —Å –±–∏—Ä–∂–∏ ' +
    'Binance –≤ –ø–∞—Ä–∞—Ö —Å –±–∏—Ç–∫–æ–∏–Ω–æ–º –∏ USDT (–¥–ª—è —ç—Ç–æ–≥–æ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –≤–≤–µ—Å—Ç–∏ —Ç–∏–∫–µ—Ä –∞–∫—Ç–∏–≤–∞ (–ù–∞–ø—Ä–∏–º–µ—Ä, eth)), ' +
    '–∞ —Ç–∞–∫–∂–µ –æ—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å –≤–≤–µ–¥–µ–Ω–Ω—ã–µ –í–∞–º–∏ –∞–∫—Ç–∏–≤—ã(–∫–æ–º–∞–Ω–¥–∞ /set). ', reply_markup=markup_author)

@bot.message_handler(commands=['getinfobot'])
def get_info_bitbullbot(message):
    all_users = str(dbhelper.get_number_of_all_users())
    bot.send_message(message.chat.id, '‚Ñπ–ü–æ–¥–∫–ª—é—á–∞—é—Å—å –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö –∏ –ø–æ–ª—É—á–∞—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é........')


@bot.message_handler(commands=['set'], func=lambda message: get_state(message) == GOTOSET)
def message_to_set_coins(message):
    bot.send_message(message.chat.id, '–ù–∞–ø–∏—à–∏—Ç–µ —Ç–æ–∫–µ–Ω—ã, —Ü–µ–Ω—ã –∫–æ—Ç–æ—Ä—ã—Ö –í—ã –±—ã —Ö–æ—Ç–µ–ª–∏ –æ—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å, –∫–æ—Ç–∏—Ä–æ–≤–∫–∏ '+
                            '–±—É–¥—É—Ç –±—Ä–∞—Ç—å—Å—è —Å –ø–æ—Ä—Ç–∞–ª–∞ CoinMarketCap.\n–í–≤–æ–¥–∏—Ç–µ —Ç–∏–∫–µ—Ä—ã —Ç–æ–∫–µ–Ω–æ–≤ —á–µ—Ä–µ–∑ –ø—Ä–æ–±–µ–ª. ' +
                            '<b>–ù–∞–ø—Ä–∏–º–µ—Ä, btc eth ada xrp.</b> \n\n' +
                            '–ü–æ—Å–ª–µ —ç—Ç–æ–≥–æ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –Ω–∞–∂–∞—Ç—å –∫–Ω–æ–ø–∫—É My CoinMarket –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç',
                                parse_mode='HTML')
    update_state(message, FINAL)
    # bot.send_message(message.chat.id, '–Ø —Ç—É—Ç')

@bot.message_handler(func=lambda message: get_state(message) == FINAL)
def set_crypto(message):
    bot.send_message(message.chat.id, '–ü—Ä–æ–≤–µ—Ä—è—é –Ω–∞–ª–∏—á–∏–µ –≤–≤–µ–¥–µ–Ω–Ω—ã—Ö –∞–∫—Ç–∏–≤–æ–≤ –Ω–∞ CoinMarketCap.....')
    tickers = list(set([elem.upper() for elem in message.text.split()]))
    print(tickers)
    check = []
    data = market.get_data()
    for i in tickers:
        for j in data['data']:
            if i == j['symbol'] and j['name'] != 'BuySell':
                check.append(i)
    if len(check) != 0:
        text = '–ò–∑ –≤–≤–µ–¥–µ–Ω–Ω—ã—Ö –í–∞–º–∏ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç –±—É–¥—É—Ç –æ—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å—Å—è —Ç–∞–∫–∏–µ –∞–∫—Ç–∏–≤—ã: \n'
        for i in check:
            text += i + '\n'
        info = User.objects.get(user_id=message.chat.id)
        info.coins = check
        info.save()
        bot.send_message(message.chat.id, text, reply_markup=keyboard_1)
    else:
        bot.send_message(message.chat.id, '–ò–∑ –≤–≤–µ–¥–µ–Ω–Ω—ã—Ö –í–∞–º–∏ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç –Ω–∏ –æ–¥–Ω–∞ –Ω–µ —Ç–æ—Ä–≥—É–µ—Ç—Å—è –Ω–∞ CoinMarketCap. ' +
                                            '–ù–∞–∂–º–∏—Ç–µ /set –∏ –≤–≤–µ–¥–∏—Ç–µ –∞–∫—Ç–∏–≤—ã –µ—â–µ —Ä–∞–∑. ')
    update_state(message, GOTOSET)

@bot.message_handler(content_types=['text'], func=lambda message: get_state(message) != FINAL)
def message_cryptos(message):
    if message.text.lower() == 'my marketcap':
        get_data = dbhelper.get_user_crypto(message.chat.id)
        if not get_data:
            bot.send_message(message.chat.id, 'B –±–∞–∑–µ –Ω–µ—Ç –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º—ã—Ö –í–∞–º–∏ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç, –Ω–∞–∂–º–∏—Ç–µ /set, ' +
            '—á—Ç–æ–±—ã —É–∫–∞–∑–∞—Ç—å –∂–µ–ª–∞–µ–º—ã–µ —Ü–∏—Ñ—Ä–æ–≤—ã–µ –∞–∫—Ç–∏–≤—ã.')
        else:
            bot.send_message(message.chat.id, '–ë–µ—Ä—É –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –í–∞—à–∏—Ö —Ç–æ–∫–µ–Ω–∞—Ö –∏ —Å–≤—è–∑—ã–≤–∞—é—Å—å —Å CoinMarketCap......')
            drop_db = get_data.replace('{','').replace('}', '').split(',')
            data = market.get_data()
            now = datetime.datetime.now()
            id = 1
            text = '–û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º—ã–µ –í–∞–º–∏ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç—ã: \n\n'
            for i in drop_db:
                for j in data['data']:
                    if i == j['symbol'] and j['name'] != 'BuySell':
                        text += '<b>‚Ññ' + str(id) + '</b> <i>' +j['name'] + '</i> <code>' + str(round(j['quote']['USD']['price'], 3)) + '</code> USD ' + \
                                str(round(j['quote']['USD']['percent_change_24h'], 2)) + '(%|24h)\n\n'

                        id += 1
            text += '<b>–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è —Å –ø–æ—Ä—Ç–∞–ª–∞ CoinMarketCap –ø–æ —Å–æ—Å—Ç–æ—è–Ω–∏—é –Ω–∞ ' + now.strftime("%d-%m-%Y") + '.</b>\n\n'
            text += '<i>–í—ã –≤—Å–µ–≥–¥–∞ –º–æ–∂–µ—Ç–µ –∏–∑–º–µ–Ω–∏—Ç—å –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º—ã–µ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç—ã —Å –ø–æ–º–æ—â—å—é –∫–æ–º–∞–Ω–¥—ã</i> /set'
            bot.send_message(message.chat.id, text, parse_mode='HTML')
    else:
        text_up = message.text.upper()
        mes_usdt = parse.get_crypto_to_usdt(message.text)
        mes_btc = parse.get_crypto_to_btc(message.text)
        bot.send_message(message.chat.id, '‚Ñπ–ü–æ–¥–∫–ª—é—á–∞—é—Å—å –∫ Binance, –±–µ—Ä—É –∞–∫—Ç—É–∞–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é')
        text = '~~~~~~~~~~~~~\n'+'–î–∞–Ω–Ω—ã–µ —Å –±–∏—Ä–∂–∏ üî∏Binanceüî∏\n'+'~~~~~~~~~~~~~\n'+'–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –ø–æ –ø–∞—Ä–µ ' + text_up + '-USDT:\n' +\
                '1 ' + text_up + ' = ' + mes_usdt + '\n' +'–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –ø–æ –ø–∞—Ä–µ ' + text_up + '-BTC:\n' + '1 ' + text_up + ' = ' +\
                 mes_btc + '\n'
        if '–Ω–µ —Ç–æ—Ä–≥—É–µ—Ç—Å—è' in mes_usdt and mes_btc:
            bot.send_message(message.chat.id, '–í–≤–µ–¥–µ–Ω–Ω—ã–π –í–∞–º–∏ —Ç–∏–∫–µ—Ä —Ç–æ–∫–µ–Ω–∞ –Ω–µ —Ç–æ—Ä–≥—É–µ—Ç—Å—è –ø—Ä–æ—Ç–∏–≤ USDT –∏ BTC')
        else:
            bot.send_message(message.chat.id, text, parse_mode='HTML')


@bot.callback_query_handler(func=lambda call: True)
def inline_buttons(call):
    if call.message:
        if call.data == 'getall':
            help_file = open('all.txt', 'rb')
            bot.send_document(call.message.chat.id, help_file)
        elif call.data == 'author':
            bot.send_message(call.message.chat.id, '–ö–æ–º–∞–Ω–¥–∞ 2348', parse_mode='HTML')

# CRYPTOS = defaultdict(lambda: {})
#
# def update_cryptos(id, name, values):
#     dbhelper.write_users_crypto(id, name, values)
# def get_cryptos(id):
#     return CRYPTOS[id]
# bot.polling(none_stop=True)
if __name__ == '__main__':
    app.run(host="0.0.0.0", port=int(os.environ.get('PORT', 5000)))
